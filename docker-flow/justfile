image_name := 'gcr.io/dm-docker/demo/scala:dev'
jar_name := 'application.jar'
work_dir := '/opt/spark/work-dir'
cluster_url := 'https://demo.datamechanics.co'
api_key := 'null'

# Build the JAR
build_jar:
    sbt assembly

# Build the image and push it to the registry
build_image:
    docker build -t {{image_name}} .

# Build everything and push it to the registry
update_registry: build_jar build_image
    docker push {{image_name}}

# Run locally with JAR mounted
run_locally_mounted main_class +args='':
    docker run --mount type=bind,source="$(pwd)",target={{work_dir}} \
        {{image_name}} driver --class {{main_class}} local://{{work_dir}}/target/scala-2.12/{{jar_name}} {{args}}

# Run locally with JAR baked-in
run_locally main_class +args='':
    docker run \
        {{image_name}} driver --class {{main_class}} local://{{work_dir}}/{{jar_name}} {{args}}

# Run JAR locally
run_spark_pi_locally arg='10': (run_locally 'co.datamechanics.pi.Main' arg)

# Run JAR locally
run_spark_pi_locally_mounted arg='10': (run_locally 'co.datamechanics.pi.Main' arg)

# Run JAR on Data Mechanics
run_spark_pi_on_cluster arg='100':
    #!/bin/bash
    output=$(curl -s --request POST {{cluster_url}}/api/apps/ \
        --header 'Content-Type: application/json' \
        --header 'X-API-Key: {{api_key}}' \
        --data-raw '{
          "jobName": "scala-spark-pi",
          "configOverrides": {
            "type": "Scala",
            "sparkVersion": "3.0.1",
            "image": "{{image_name}}",
            "imagePullPolicy": "Always",
            "mainApplicationFile": "local://{{work_dir}}/{{jar_name}}",
            "mainClass": "co.datamechanics.pi.Main",
            "arguments": ["{{arg}}"]
          }
        }')
    echo $output | jq -r
    app_name=$(echo $output | jq -r '.appName')
    echo "Check out the app at {{cluster_url}}/dashboard/apps/$app_name"
    just api_key={{api_key}} cluster_url={{cluster_url}} _stream_logs $app_name

# Get the status of an app
_get_app_state app_name:
    @curl -s --request GET {{cluster_url}}/api/apps/{{app_name}} \
        --header 'Content-Type: application/json' \
        --header 'X-API-Key: {{api_key}}' | jq -r '.status.state'

# Print the live driver log stream of an app
_stream_logs app_name:
    #!/bin/bash
    app_state="null"
    echo {{app_name}}
    while [ "$app_state" = "null" -o "$app_state" = "SUBMITTED" -o "$app_state" = "" ]
    do
        app_state=$(just api_key={{api_key}} cluster_url={{cluster_url}} _get_app_state {{app_name}})
        echo "App is in state $app_state, waiting..."
        sleep 1
    done
    curl --request GET {{cluster_url}}/api/apps/{{app_name}}/live/driver-log \
        --header 'Content-Type: application/json' \
        --header 'X-API-Key: {{api_key}}'
